{"ast":null,"code":"import _slicedToArray from\"/Users/sebastianacosta/Bootcamp/giffy/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import{useState,useEffect,useRef}from'react';export default function useNearScreen(){var _ref=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},_ref$distance=_ref.distance,distance=_ref$distance===void 0?'100px':_ref$distance,externalRef=_ref.externalRef,_ref$once=_ref.once,once=_ref$once===void 0?true:_ref$once;var _useState=useState(false),_useState2=_slicedToArray(_useState,2),show=_useState2[0],setShow=_useState2[1];var ref=useRef();useEffect(function(){var observer;var el=externalRef?externalRef.current:ref.current;var onChange=function onChange(entries,observer){var element=entries[0];if(element.isIntersecting){setShow(true);once&&observer.disconnect();}else{!once&&setShow(false);}};Promise.resolve(typeof IntersectionObserver!=='undefined'?IntersectionObserver:import('intersection-observer')).then(function(){observer=new IntersectionObserver(onChange,{rootMargin:distance});//\nobserver.observe(el);//  observer.observe(ref.current)\n});return function(){return observer&&observer.disconnect();};});return{show:show,ref:ref};}","map":{"version":3,"names":["useState","useEffect","useRef","useNearScreen","distance","externalRef","once","show","setShow","ref","observer","el","current","onChange","entries","element","isIntersecting","disconnect","Promise","resolve","IntersectionObserver","then","rootMargin","observe"],"sources":["/Users/sebastianacosta/Bootcamp/giffy/src/hooks/isNearscreen.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react'\n\nexport  default  function useNearScreen({distance= '100px', \nexternalRef, once = true }= {}){\n\n    const [show , setShow] = useState(false)\n\n    const ref = useRef()\n\n    \n\n    \n    useEffect(function(){\n\n        let observer ;\n\n       const el = externalRef? externalRef.current: ref.current\n\n     \n\n      \n\n        const onChange = (entries, observer) =>{\n        \n            const element = entries[0]\n\n\n            \n            if (element.isIntersecting)\n            {\n                setShow(true)\n\n               once && observer.disconnect()\n            }else{\n                !once && setShow(false)\n            }\n         \n        \n        }\n\n    \n\n    Promise.resolve(\n        typeof IntersectionObserver !== 'undefined'\n        ?\n        IntersectionObserver\n        :\n        import ('intersection-observer')\n    ).then(()=>{\n        observer = new IntersectionObserver(onChange, {\n            rootMargin: distance\n        })\n\n        //\n        observer.observe(el)\n\n        //  observer.observe(ref.current)\n    })\n\n    return () => observer && observer.disconnect()\n\n    })\n\n    \n   \n    \n    \n\n     return {show, ref}\n}"],"mappings":"2HAAA,OAASA,QAAT,CAAmBC,SAAnB,CAA8BC,MAA9B,KAA4C,OAA5C,CAEA,cAAiB,SAASC,cAAT,EACc,oEAAH,EAAG,oBADUC,QACV,CADUA,QACV,wBADoB,OACpB,eAA/BC,WAA+B,MAA/BA,WAA+B,gBAAlBC,IAAkB,CAAlBA,IAAkB,oBAAX,IAAW,WAE3B,cAAyBN,QAAQ,CAAC,KAAD,CAAjC,wCAAOO,IAAP,eAAcC,OAAd,eAEA,GAAMC,IAAG,CAAGP,MAAM,EAAlB,CAKAD,SAAS,CAAC,UAAU,CAEhB,GAAIS,SAAJ,CAED,GAAMC,GAAE,CAAGN,WAAW,CAAEA,WAAW,CAACO,OAAd,CAAuBH,GAAG,CAACG,OAAjD,CAMC,GAAMC,SAAQ,CAAG,QAAXA,SAAW,CAACC,OAAD,CAAUJ,QAAV,CAAsB,CAEnC,GAAMK,QAAO,CAAGD,OAAO,CAAC,CAAD,CAAvB,CAIA,GAAIC,OAAO,CAACC,cAAZ,CACA,CACIR,OAAO,CAAC,IAAD,CAAP,CAEDF,IAAI,EAAII,QAAQ,CAACO,UAAT,EAAR,CACF,CALD,IAKK,CACD,CAACX,IAAD,EAASE,OAAO,CAAC,KAAD,CAAhB,CACH,CAGJ,CAhBD,CAoBJU,OAAO,CAACC,OAAR,CACI,MAAOC,qBAAP,GAAgC,WAAhC,CAEAA,oBAFA,CAIA,OAAQ,uBAAR,CALJ,EAMEC,IANF,CAMO,UAAI,CACPX,QAAQ,CAAG,GAAIU,qBAAJ,CAAyBP,QAAzB,CAAmC,CAC1CS,UAAU,CAAElB,QAD8B,CAAnC,CAAX,CAIA;AACAM,QAAQ,CAACa,OAAT,CAAiBZ,EAAjB,EAEA;AACH,CAfD,EAiBA,MAAO,kBAAMD,SAAQ,EAAIA,QAAQ,CAACO,UAAT,EAAlB,EAAP,CAEC,CAjDQ,CAAT,CAwDC,MAAO,CAACV,IAAI,CAAJA,IAAD,CAAOE,GAAG,CAAHA,GAAP,CAAP,CACJ"},"metadata":{},"sourceType":"module"}