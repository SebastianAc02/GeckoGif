{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect, useRef } from 'react';\nexport default function useNearScreen() {\n  _s();\n\n  let {\n    distance = '1px',\n    externalRef\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const [show, setShow] = useState(false);\n  const ref = useRef();\n  useEffect(function () {\n    let observer;\n    const el = externalRef ? externalRef.current : ref.current;\n\n    const onChange = (entries, observer) => {\n      const element = entries[0];\n\n      if (element.isIntersecting) {\n        setShow(true);\n        observer.disconnect();\n      }\n    };\n\n    Promise.resolve(typeof IntersectionObserver !== 'undefined' ? IntersectionObserver : import('intersection-observer')).then(() => {\n      observer = new IntersectionObserver(onChange, {\n        rootMargin: distance\n      }); //\n\n      observer.observe(el); //  observer.observe(ref.current)\n    });\n    return () => observer && observer.disconnect();\n  });\n  return {\n    show,\n    ref\n  };\n}\n\n_s(useNearScreen, \"gA/s96N0xPoLh9/XoPY84kthx1c=\");","map":{"version":3,"names":["useState","useEffect","useRef","useNearScreen","distance","externalRef","show","setShow","ref","observer","el","current","onChange","entries","element","isIntersecting","disconnect","Promise","resolve","IntersectionObserver","then","rootMargin","observe"],"sources":["/Users/sebastianacosta/Bootcamp/giffy/src/hooks/isNearscreen.js"],"sourcesContent":["import { useState, useEffect, useRef } from 'react'\n\nexport  default  function useNearScreen({distance= '1px', externalRef}= {}){\n\n    const [show , setShow] = useState(false)\n\n    const ref = useRef()\n\n\n    \n    useEffect(function(){\n\n        let observer\n\n       const el = externalRef? externalRef.current: ref.current\n\n\n      \n\n        const onChange = (entries, observer) =>{\n        \n            const element = entries[0]\n        \n            \n            if (element.isIntersecting)\n            {\n                setShow(true)\n                observer.disconnect()\n            }\n         \n        \n        }\n\n    \n\n    Promise.resolve(\n        typeof IntersectionObserver !== 'undefined'\n        ?\n        IntersectionObserver\n        :\n        import ('intersection-observer')\n    ).then(()=>{\n        observer = new IntersectionObserver(onChange, {\n            rootMargin: distance\n        })\n\n        //\n        observer.observe(el)\n\n        //  observer.observe(ref.current)\n    })\n\n    return () => observer && observer.disconnect()\n\n    })\n\n\n     return {show, ref}\n}"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,MAA9B,QAA4C,OAA5C;AAEA,eAAiB,SAASC,aAAT,GAA0D;EAAA;;EAAA,IAAnC;IAACC,QAAQ,GAAE,KAAX;IAAkBC;EAAlB,CAAmC,uEAAH,EAAG;EAEvE,MAAM,CAACC,IAAD,EAAQC,OAAR,IAAmBP,QAAQ,CAAC,KAAD,CAAjC;EAEA,MAAMQ,GAAG,GAAGN,MAAM,EAAlB;EAIAD,SAAS,CAAC,YAAU;IAEhB,IAAIQ,QAAJ;IAED,MAAMC,EAAE,GAAGL,WAAW,GAAEA,WAAW,CAACM,OAAd,GAAuBH,GAAG,CAACG,OAAjD;;IAKC,MAAMC,QAAQ,GAAG,CAACC,OAAD,EAAUJ,QAAV,KAAsB;MAEnC,MAAMK,OAAO,GAAGD,OAAO,CAAC,CAAD,CAAvB;;MAGA,IAAIC,OAAO,CAACC,cAAZ,EACA;QACIR,OAAO,CAAC,IAAD,CAAP;QACAE,QAAQ,CAACO,UAAT;MACH;IAGJ,CAZD;;IAgBJC,OAAO,CAACC,OAAR,CACI,OAAOC,oBAAP,KAAgC,WAAhC,GAEAA,oBAFA,GAIA,OAAQ,uBAAR,CALJ,EAMEC,IANF,CAMO,MAAI;MACPX,QAAQ,GAAG,IAAIU,oBAAJ,CAAyBP,QAAzB,EAAmC;QAC1CS,UAAU,EAAEjB;MAD8B,CAAnC,CAAX,CADO,CAKP;;MACAK,QAAQ,CAACa,OAAT,CAAiBZ,EAAjB,EANO,CAQP;IACH,CAfD;IAiBA,OAAO,MAAMD,QAAQ,IAAIA,QAAQ,CAACO,UAAT,EAAzB;EAEC,CA5CQ,CAAT;EA+CC,OAAO;IAACV,IAAD;IAAOE;EAAP,CAAP;AACJ;;GAxDyBL,a"},"metadata":{},"sourceType":"module"}