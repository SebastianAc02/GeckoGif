{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar react = require('react');\n/**\n * History API docs @see https://developer.mozilla.org/en-US/docs/Web/API/History\n */\n\n\nconst eventPopstate = \"popstate\";\nconst eventPushState = \"pushState\";\nconst eventReplaceState = \"replaceState\";\nconst events = [eventPopstate, eventPushState, eventReplaceState];\n\nvar locationHook = function () {\n  let {\n    base = \"\"\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const [{\n    path,\n    search\n  }, update] = react.useState(() => ({\n    path: currentPathname(base),\n    search: location.search\n  })); // @see https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\n\n  const prevHash = react.useRef(path + search);\n  react.useEffect(() => {\n    // this function checks if the location has been changed since the\n    // last render and updates the state only when needed.\n    // unfortunately, we can't rely on `path` value here, since it can be stale,\n    // that's why we store the last pathname in a ref.\n    const checkForUpdates = () => {\n      const pathname = currentPathname(base);\n      const search = location.search;\n      const hash = pathname + search;\n\n      if (prevHash.current !== hash) {\n        prevHash.current = hash;\n        update({\n          path: pathname,\n          search\n        });\n      }\n    };\n\n    events.forEach(e => addEventListener(e, checkForUpdates)); // it's possible that an update has occurred between render and the effect handler,\n    // so we run additional check on mount to catch these updates. Based on:\n    // https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\n\n    checkForUpdates();\n    return () => events.forEach(e => removeEventListener(e, checkForUpdates));\n  }, [base]); // the 2nd argument of the `useLocation` return value is a function\n  // that allows to perform a navigation.\n  //\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n\n  const navigate = react.useCallback(function (to) {\n    let {\n      replace = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return history[replace ? eventReplaceState : eventPushState](null, \"\", // handle nested routers and absolute paths\n    to[0] === \"~\" ? to.slice(1) : base + to);\n  }, [base]);\n  return [path, navigate];\n}; // While History API does have `popstate` event, the only\n// proper way to listen to changes via `push/replaceState`\n// is to monkey-patch these methods.\n//\n// See https://stackoverflow.com/a/4585031\n\n\nif (typeof history !== \"undefined\") {\n  for (const type of [eventPushState, eventReplaceState]) {\n    const original = history[type];\n\n    history[type] = function () {\n      const result = original.apply(this, arguments);\n      const event = new Event(type);\n      event.arguments = arguments;\n      dispatchEvent(event);\n      return result;\n    };\n  }\n}\n\nconst currentPathname = function (base) {\n  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : location.pathname;\n  return !path.toLowerCase().indexOf(base.toLowerCase()) ? path.slice(base.length) || \"/\" : \"~\" + path;\n};\n\nexports[\"default\"] = locationHook;\nexports.events = events;","map":{"version":3,"names":["Object","defineProperty","exports","value","react","require","eventPopstate","eventPushState","eventReplaceState","events","locationHook","base","path","search","update","useState","currentPathname","location","prevHash","useRef","useEffect","checkForUpdates","pathname","hash","current","forEach","e","addEventListener","removeEventListener","navigate","useCallback","to","replace","history","slice","type","original","result","apply","arguments","event","Event","dispatchEvent","toLowerCase","indexOf","length"],"sources":["/Users/sebastianacosta/Bootcamp/giffy/node_modules/wouter/cjs/use-location.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar react = require('react');\n\n/**\n * History API docs @see https://developer.mozilla.org/en-US/docs/Web/API/History\n */\nconst eventPopstate = \"popstate\";\nconst eventPushState = \"pushState\";\nconst eventReplaceState = \"replaceState\";\nconst events = [eventPopstate, eventPushState, eventReplaceState];\n\nvar locationHook = ({ base = \"\" } = {}) => {\n  const [{ path, search }, update] = react.useState(() => ({\n    path: currentPathname(base),\n    search: location.search,\n  })); // @see https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\n  const prevHash = react.useRef(path + search);\n\n  react.useEffect(() => {\n    // this function checks if the location has been changed since the\n    // last render and updates the state only when needed.\n    // unfortunately, we can't rely on `path` value here, since it can be stale,\n    // that's why we store the last pathname in a ref.\n    const checkForUpdates = () => {\n      const pathname = currentPathname(base);\n      const search = location.search;\n      const hash = pathname + search;\n\n      if (prevHash.current !== hash) {\n        prevHash.current = hash;\n        update({ path: pathname, search });\n      }\n    };\n\n    events.forEach((e) => addEventListener(e, checkForUpdates));\n\n    // it's possible that an update has occurred between render and the effect handler,\n    // so we run additional check on mount to catch these updates. Based on:\n    // https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\n    checkForUpdates();\n\n    return () => events.forEach((e) => removeEventListener(e, checkForUpdates));\n  }, [base]);\n\n  // the 2nd argument of the `useLocation` return value is a function\n  // that allows to perform a navigation.\n  //\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n  const navigate = react.useCallback(\n    (to, { replace = false } = {}) =>\n      history[replace ? eventReplaceState : eventPushState](\n        null,\n        \"\",\n        // handle nested routers and absolute paths\n        to[0] === \"~\" ? to.slice(1) : base + to\n      ),\n    [base]\n  );\n\n  return [path, navigate];\n};\n\n// While History API does have `popstate` event, the only\n// proper way to listen to changes via `push/replaceState`\n// is to monkey-patch these methods.\n//\n// See https://stackoverflow.com/a/4585031\nif (typeof history !== \"undefined\") {\n  for (const type of [eventPushState, eventReplaceState]) {\n    const original = history[type];\n\n    history[type] = function () {\n      const result = original.apply(this, arguments);\n      const event = new Event(type);\n      event.arguments = arguments;\n\n      dispatchEvent(event);\n      return result;\n    };\n  }\n}\n\nconst currentPathname = (base, path = location.pathname) =>\n  !path.toLowerCase().indexOf(base.toLowerCase())\n    ? path.slice(base.length) || \"/\"\n    : \"~\" + path;\n\nexports[\"default\"] = locationHook;\nexports.events = events;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}